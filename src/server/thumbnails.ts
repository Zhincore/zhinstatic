import { existsSync } from "node:fs";
import fs from "node:fs/promises";
import Path from "node:path";
import Sharp from "sharp";
import type { FormatEnum } from "sharp";
import Limit from "p-limit";
import { error } from "@sveltejs/kit";
import { getFile } from "$server/files";
import type { FileInfo } from "$server/files";
import { serverConfig } from "./config";
import { ffmpegThumbnail } from "./filesSubprocess";

export type ThumbnailFormat = typeof serverConfig.thumbnails.formats[number];

// Use max one third of available threads for FFmpeg, min 1
const fflimit = Limit(1);

const queue = new Map<string, Promise<string | undefined>>();

export async function getThumbnail(...args: Parameters<typeof _getThumbnail>): ReturnType<typeof _getThumbnail> {
  // Prevent one thumbnail to be generated by multiple threads (cache-lock)
  const cached = queue.get(args[0]);
  if (cached) return cached;

  const promise = _getThumbnail(...args);
  queue.set(args[0], promise);
  promise.finally(() => queue.delete(args[0]));

  return promise;
}

Sharp.concurrency(1);
Sharp.cache(false);

async function _getThumbnail(
  path: string,
  size: number,
  format: ThumbnailFormat,
  info?: FileInfo,
  abort?: AbortSignal,
) {
  if (!serverConfig.thumbnails.formats.includes(format)) throw error(400, "Unsupported output format");
  if (!serverConfig.thumbnails.widths.includes(size)) throw error(400, "Unsupported output width");

  const outputDir = Path.join(serverConfig.thumbnails.path, size + "");
  const outputPath = Path.join(outputDir, encodeFilename(path) + "." + format);
  if (existsSync(outputPath)) return outputPath;

  if (!info) info = await getFile(path);
  const [type, inFormat] = info.mime?.split("/") ?? [];
  if (!info.mime || !["video", "image"].includes(type)) throw error(400, "Unsupported source format");
  if (info.size <= serverConfig.thumbnails.minSize || serverConfig.thumbnails.keepMimes.includes(info.mime)) { 
    return path; // keep file as is
  }
  if (info.size >= serverConfig.thumbnails.maxSize) throw error(404, "File too big");


  // AVIF is regarded as HEIF in sharp
  const mapFormat = (fmt: string) => ({ avif: "heif" }[fmt] ?? fmt);
  const sharpInSupport = Sharp.format[mapFormat(inFormat) as keyof FormatEnum]?.input.file;
  const sharpOutSupport = Sharp.format[mapFormat(format) as keyof FormatEnum]?.output.file;
  const animated = serverConfig.thumbnails.animatedMimes.includes(info.mime);

  abort?.throwIfAborted();

  await fs.mkdir(outputDir, { recursive: true });

  let inputPath = path;

  if (!sharpInSupport || !sharpOutSupport) {
    // Convert unsupported files first
    inputPath = Path.join(serverConfig.thumbnails.path, encodeFilename(path) + ".png");
    if (!existsSync(inputPath)) {
      try {
        await fflimit(() => ffmpegThumbnail(path, inputPath, Math.max(...serverConfig.thumbnails.widths)));
      } catch (err) {
        if ((err as Record<string, string>)?.code === "ENOENT") return; // FFmpeg not found
        if (process.env.NODE_ENV != "production") console.error(err);
        return;
      }
    }
  }

  abort?.throwIfAborted();

  try {
    // NOTE: Sharp has it's own queue
    await Sharp(inputPath, {
        limitInputPixels:serverConfig.thumbnails.maxPixels, 
        animated,
        pages: format === "avif" ? 1 : -1 
      })
      .rotate()
      .resize(size, size, { fit: "inside", withoutEnlargement: true })
      .toFormat(format, { mozjpeg: true, effort: 2 })
      .toFile(outputPath);
  } catch (err) {
    // TODO: Error handling?
    if (process.env.NODE_ENV != "production") console.error(err);
    return;
  }

  return outputPath;
}

function encodeFilename(path: string) {
  return path.replace(/\/|%/g, "-").replace(/-{2,}/g, "-").replace(/^-/, "");
}
